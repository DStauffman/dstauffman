r"""
Contains generic quaternion utilities that can be independently defined and used by other modules.

Notes
-----
#.  Written by David C. Stauffer in April 2015.
"""

#%% Imports
from __future__ import annotations

import doctest
import logging
from typing import List, Tuple, TYPE_CHECKING, Union
import unittest

from slog import LogLevel

from dstauffman import HAVE_NUMPY, INT_TOKEN
from dstauffman.aerospace.quat_opt import quat_to_dcm

if HAVE_NUMPY:
    import numpy as np

    if TYPE_CHECKING:
        from numpy.typing import ArrayLike

#%% Loggers
logger = logging.getLogger(__name__)

#%% Constants
# Number of elements that should be in a quaternion
QUAT_SIZE = 4

#%% Master flags
# Flag controls whether any quaternion solutions are run
_USE_ASSERTIONS = True

#%% Functions - suppress_quat_checks
def suppress_quat_checks() -> None:
    r"""
    Function that allows you to globally suppres the display of any plots generated by the library.

    Notes
    -----
    #.  Modified from a class to a function based version by David C. Stauffer in November 2020.

    Examples
    --------
    >>> from dstauffman.aerospace import suppress_quat_checks
    >>> suppress_quat_checks()

    """
    global _USE_ASSERTIONS
    _USE_ASSERTIONS = False


#%% Functions - unsuppress_quat_checks
def unsuppress_quat_checks() -> None:
    r"""
    Function that allows you to globally un-suppress the display of any plots so they will be shown again.

    Notes
    -----
    #.  Modified from a class to a function based version by David C. Stauffer in November 2020.

    Examples
    --------
    >>> from dstauffman.aerospace import unsuppress_quat_checks
    >>> unsuppress_quat_checks()

    """
    global _USE_ASSERTIONS
    _USE_ASSERTIONS = True


#%% Functions - quat_assertions
def quat_assertions(
    quat: np.ndarray, *, precision: float = 1e-12, skip_assertions: bool = False, allow_nans: bool = False
) -> None:
    r"""
    Check assertions about valid quaternions.

    Parameters
    ----------
    quat : ndarray, (4,) or (4, N)
        Quaternion
    precision : float
        Limit for how close to normalized the quaternion needs to be
    skip_assertions : bool
        Flag to override all the checks
    allow_nans : bool, optional, default is False
        Whether to allow quaternions of all NaNs

    Examples
    --------
    >>> from dstauffman.aerospace import quat_assertions
    >>> import numpy as np
    >>> quat = np.array([0.5, 0.5, -0.5, 0.5])
    >>> quat_assertions(quat)

    """
    if not _USE_ASSERTIONS or skip_assertions:
        return
    # get sizes
    qsize = quat.size
    qndim = quat.ndim
    # check sizes and dimensions
    if qndim == 1:
        assert qsize == 0 or qsize == QUAT_SIZE, 'Quaternion has invalid size: "{}"'.format(qsize)
    elif qndim == 2:
        assert quat.shape[0] == QUAT_SIZE, "Quaternion has invalid size for first " + 'dimension: "{}"'.format(quat.shape[0])
    else:
        assert False, 'Quaternion has too many dimensions: "{}".'.format(qndim)
    # if a null quaternion, then checks are done
    if qsize == 0:
        return
    # check that values are all real
    assert np.all(np.isreal(quat)), "Quaternion is not real"
    # check ranges
    if qndim == 1:
        if np.any(nans := np.isnan(quat)):
            if allow_nans:
                assert np.all(nans), "Quaternions with NaNs must have NaNs for every component."
            else:
                assert False, "NaNs are not allow in quaternion."
        else:
            assert -1 <= quat[0] <= 1, 'Quaternion has bad range in x value: "{}"'.format(quat[0])
            assert -1 <= quat[1] <= 1, 'Quaternion has bad range in y value: "{}"'.format(quat[1])
            assert -1 <= quat[2] <= 1, 'Quaternion has bad range in z value: "{}"'.format(quat[2])
            assert  0 <= quat[3] <= 1, 'Quaternion has bad range in s value: "{}"'.format(quat[3])  # fmt: skip
    else:
        if np.any(nans := np.isnan(quat)):
            if allow_nans:
                # TODO: this is a hack for typing!  set command is valid
                temp = "Quaternions with NaNs must have NaNs for every component."
                assert set(np.count_nonzero(nans, axis=0)).issubset({0, 4}), temp
            else:
                assert False, "NaNs are not allow in quaternion."
        ix = ~np.isnan(quat[0, :])
        assert np.all(-1 <= quat[0, ix]) and np.all(
            quat[0, ix] <= 1
        ), 'Quaternion has bad range in x value, min: "{}", max:"{}"'.format(np.min(quat[0, ix]), np.max(quat[0, ix]))
        assert np.all(-1 <= quat[1, ix]) and np.all(
            quat[1, ix] <= 1
        ), 'Quaternion has bad range in y value, min: "{}", max:"{}"'.format(np.min(quat[1, ix]), np.max(quat[1, ix]))
        assert np.all(-1 <= quat[2, ix]) and np.all(
            quat[2, ix] <= 1
        ), 'Quaternion has bad range in z value, min: "{}", max:"{}"'.format(np.min(quat[2, ix]), np.max(quat[2, ix]))
        assert np.all(0 <= quat[3, ix]) and np.all(
            quat[3, ix] <= 1
        ), 'Quaternion has bad range in s value, min: "{}", max:"{}"'.format(np.min(quat[3, ix]), np.max(quat[3, ix]))

    # check normalization
    q_norm_err = np.abs(1 - np.sum(quat**2, axis=0))
    norm_check = q_norm_err <= precision
    if allow_nans:
        norm_check |= np.isnan(q_norm_err)
    assert np.all(norm_check), 'Quaternion has invalid normalization error "{}".'.format(np.max(q_norm_err))


#%% Functions - enforce_pos_scalar
def enforce_pos_scalar(quat: np.ndarray, inplace: bool = False) -> np.ndarray:
    r"""
    Enforces the standard of a positive scalar component.

    Parameters
    ----------
    quat : ndarray, (4,) or (4, N)
        Quaternion
    inplace : bool, optional, default is False
        Whether to modify the input in-place

    Returns
    -------
    qout: ndarray, (4, ) or (4, N)
        Output quaternion with strictly non-negative scalar components

    Notes
    -----
    #.  Separated into a stand-alone function by David C. Stauffer in April 2021.

    Examples
    --------
    >>> from dstauffman.aerospace import enforce_pos_scalar
    >>> import numpy as np
    >>> quat = np.array([0.5, -0.5, 0.5, -0.5])
    >>> qout = enforce_pos_scalar(quat)
    >>> print(qout)  # doctest: +NORMALIZE_WHITESPACE
    [-0.5 0.5 -0.5 0.5]

    """
    # Scalar element (fourth element) of quaternion must not be negative.
    # So change sign on entire quaternion if qout[3] is less than zero.
    qout = quat if inplace else quat.copy()
    if qout.ndim == 1:
        if ~np.isnan(qout[3]) and qout[3] < 0:
            qout[:] = -qout
        return qout
    negs = np.zeros(qout.shape[1], dtype=bool)
    negs = np.less(qout[3, :], 0, out=negs, where=~np.isnan(qout[3, :]))
    qout[:, negs] = -qout[:, negs]
    return qout


#%% Functions - qrot
def qrot(axis: ArrayLike, angle: ArrayLike, **kwargs) -> np.ndarray:
    r"""
    Construct a quaternion expressing a rotation about a single axis.

    Parameters
    ----------
    axis : int
        Axis about which rotation is being made, from {1, 2, 3}
            (1) for x-axis
            (2) for y-axis
            (3) for z-axis
    angle : array_like
        angle of rotation in radians

    Returns
    -------
    quat : ndarray, (4,) or (4, N)
        quaternion representing the given rotations

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.

    References
    ----------
    .. [1]  Wertz, James R. (editor), Equations 12.11 in Parameterization of the Attitude,
            Section 12.1, Spacecraft Attitude Determination and Control,
            Kluwer Academic Publishers, 1978.

    Examples
    --------
    >>> from dstauffman.aerospace import qrot
    >>> import numpy as np
    >>> quat = qrot(3, np.pi/2)
    >>> with np.printoptions(precision=8):
    ...     print(quat) # doctest: +NORMALIZE_WHITESPACE
    [0. 0. 0.70710678  0.70710678]

    """
    # assertions
    try:
        axis_set = set(axis)  # type: ignore[arg-type]
    except TypeError:
        axis_set = {axis}
    assert len(axis_set - {1, 2, 3}) == 0, "axis_set = {}".format(axis_set)
    # calculations
    quat: np.ndarray
    if np.isscalar(angle) and np.isscalar(axis):
        # optimized scalar case
        quat = np.array([0, 0, 0, np.cos(angle / 2)])  # type: ignore[operator]
        quat[axis - 1] = np.sin(angle / 2)  # type: ignore[operator]
    elif np.isscalar(axis):
        # single axis, multiple angle case
        quat = np.vstack((np.zeros((3, np.size(angle))), np.expand_dims(np.cos(angle / 2), axis=0)))  # type: ignore[operator]
        quat[axis - 1, :] = np.sin(angle / 2)  # type: ignore[operator]
    elif np.isscalar(angle):
        # single angle, multiple axis case
        quat = np.tile(np.array([[0], [0], [0], [np.cos(angle / 2)]]), (1, np.size(axis)))  # type: ignore[operator]
        quat[axis - 1, np.arange(np.size(axis))] = np.sin(angle / 2)  # type: ignore[operator]
    else:
        # multiple axis, multiple angle case
        assert np.size(axis) == np.size(angle)
        quat = np.vstack((np.zeros((3, np.size(angle))), np.expand_dims(np.cos(angle / 2), axis=0)))  # type: ignore[operator]
        quat[axis - 1, np.arange(np.size(axis))] = np.sin(angle / 2)  # type: ignore[operator]
    enforce_pos_scalar(quat, inplace=True)
    quat_assertions(quat, **kwargs)
    return quat


#%% Functions - quat_from_axis_angle
def quat_from_axis_angle(axis: ArrayLike, angle: ArrayLike, **kwargs) -> np.ndarray:
    r"""
    Construct a quaternion expressing the given rotations about the given axes.

    Parameters
    ----------
    axis : (3, ) on (3, N) np.ndarray of float
        Unit vector(s)
    angle : float or (N, ) np.ndarray of float
        angle of rotation(s) in radians

    Returns
    -------
    quat : ndarray, (4, ) or (4, N)
        quaternion representing the given rotation

    Notes
    -----
    #.  Written by David C. Stauffer in April 2021.

    References
    ----------
    #.  A quaternion is given by [x*s, y*s, z*s, c] where c = cos(theta/2) and sin=(theta/2)
        See: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation

    Examples
    --------
    >>> from dstauffman.aerospace import quat_from_axis_angle
    >>> import numpy as np
    >>> axis = np.sqrt([9/50, 16/50, 0.5])
    >>> angle = 5/180*np.pi
    >>> quat = quat_from_axis_angle(axis, angle)
    >>> with np.printoptions(precision=8):
    ...     print(quat) # doctest: +NORMALIZE_WHITESPACE
    [0.01850614 0.02467485 0.03084356 0.99904822]

    """
    # ailas the cosine and sine terms
    c = np.cos(angle / 2)  # type: ignore[operator]
    s = np.sin(angle / 2)  # type: ignore[operator]
    # scale the unit vector by the sine and concatenate the cosine term
    if axis.ndim == 1 and c.size == 1:  # type: ignore[union-attr]
        quat = np.hstack([axis * s, c])
    elif axis.ndim == 1:  # type: ignore[union-attr]
        quat = np.vstack([np.outer(axis, s), c])  # type: ignore[arg-type]
    elif c.size == 1:
        quat = np.vstack([axis * s, np.full(axis.shape[1], c)])  # type: ignore[union-attr]
    else:
        assert axis.shape[1] == c.size  # type: ignore[union-attr]
        quat = np.vstack([axis * s, c])
    # TODO: try to eliminate the four different cases:
    # e = np.outer(axis, s) if axis.ndim == 1 else axis * s
    # check for null quaternion and if found, then normalize it
    if quat.ndim == 1:
        if quat[0] == 0 and quat[1] == 0 and quat[2] == 0:
            quat[3] = 1
    else:
        ix_zeros = np.all(quat[:3, :] == 0, axis=0)
        quat[3, ix_zeros] = 1
    # enforce positive scalar component convention and reduce dimensionality if necessary
    enforce_pos_scalar(quat, inplace=True)
    quat_assertions(quat, **kwargs)
    return quat


#%% Functions - quat_angle_diff
def quat_angle_diff(quat1: np.ndarray, quat2: np.ndarray, **kwargs) -> Tuple[np.ndarray, np.ndarray]:
    r"""
    Calculate the angular difference between two quaternions.

    This function takes two quaternions and calculates a delta quaternion between them.
    It then uses the delta quaternion to generate both a total angular difference, and an
    angular difference expressed in X, Y, Z components based on the axis of rotation,
    expressed in the original frame of the quat1 input quaternion.  This function uses full
    trignometric functions instead of any small angle approximations.

    Parameters
    ----------
    quat1 : ndarray (4,) or (4, N)
        quaternion one
    quat2 : ndarray (4,) or (4, N)
        quaternion two

    Returns
    -------
    theta : ndarray (1, N)
        angular different [rad]
    comp  : ndarray (3, N)
        angle components in x, y, z frame [rad]

    References
    ----------
    This function is based on this representation of a unit quaternion:
    quat = [[nx * sin(theta/2)]
            [ny * sin(theta/2)]
            [nz * sin(theta/2)]
            [   cos(theta/2)  ]]
    Where: <nx,ny,nz> are the three components of a unit vector of rotation axis and
           theta is the angle of rotation

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.

    Examples
    --------
    >>> from dstauffman.aerospace import qrot, quat_mult, quat_angle_diff
    >>> import numpy as np
    >>> quat1 = np.array([0.5, 0.5, 0.5, 0.5])
    >>> dq1 = qrot(1, 0.001)
    >>> dq2 = qrot(2, 0.05)
    >>> quat2 = np.column_stack((quat_mult(dq1,quat1), quat_mult(dq2,quat1)))
    >>> (theta, comp) = quat_angle_diff(quat1, quat2)
    >>> with np.printoptions(precision=8):
    ...     print(theta) # doctest: +NORMALIZE_WHITESPACE
    [0.001  0.05 ]
    >>> with np.printoptions(precision=8):
    ...     print(comp) # doctest: +NORMALIZE_WHITESPACE
    [[0.001  0.   ]
     [0.     0.05 ]
     [0.     0.   ]]

    """
    # check assertions
    quat_assertions(quat1, **kwargs)
    quat_assertions(quat2, **kwargs)

    # check for null quaternions
    if quat1.size == 0 or quat2.size == 0:
        return (np.array([]), np.empty((3, 0)))

    # calculate delta quaternion
    dq = quat_mult(quat2, quat_inv(quat1, **kwargs), **kwargs)

    # pull vector components out of delta quaternion
    dv = dq[0:3, ...]

    # sum vector components to get sin(theta/2)^2
    mag2 = np.sum(dv**2, axis=0)

    # take square root to get sin(theta/2)
    mag = np.sqrt(mag2)

    # take inverse sine to get theta/2
    theta_over_2 = np.arcsin(mag)

    # multiply by 2 to get theta
    theta = 2 * theta_over_2

    # set any magnitude that is identically 0 to be 1 instead
    # to avoid a divide by zero warning.
    if np.isscalar(mag):
        if mag == 0:
            mag = 1
    else:
        mag[mag == 0] = 1

    # normalize vector components
    nv = dv / mag

    # find angle expressed in x, y, z components based on normalized vector
    comp = nv * theta

    return (theta, comp)


#%% Functions - quat_from_euler
def quat_from_euler(angles: ArrayLike, seq: ArrayLike = None, **kwargs) -> np.ndarray:
    r"""
    Convert set(s) of euler angles to quaternion(s).

    Assumes angles are of (3 1 2) euler order and converts accordingly unless the
    optional "seq" argument defines a different euler order. This function will
    also take more than three angle sequences if desired.

    Parameters
    ----------
    angles : ndarray, (A, N)
        Euler angels [rad]
    seq : ndarray, (A, 1), optional
        Euler angle sequence, where:
            1 = X axis, or roll
            2 = Y axis, or pitch
            3 = Z axis, or yaw

    Returns
    -------
    quat : ndarray (4,) or (4, N)
        quaternion representing the euler rotation(s)

    Notes
    -----
    #.  Adapted from GARSE by David C. Stauffer in April 2015.
    #.  This function will take one angle sequence, but an arbitrary number of angles.
    #.  Enumerated values are some selective permutation of (1, 2, 3) without successive
            repetition such as (3, 1, 2) or (3, 1, 3) but not (3, 1, 1) wherein 1, 1 is a successive
            repetition.  By default, it expects (3, 1, 2).
    #.  Additional keyword arguments are passed on to quat_assertions function.

    Examples
    --------
    >>> from dstauffman.aerospace import quat_from_euler
    >>> import numpy as np
    >>> a   = np.array([0.01, 0.02, 0.03])
    >>> b   = np.array([0.04, 0.05, 0.06])
    >>> angles = np.column_stack((a, b))
    >>> seq = np.array([3, 2, 1])
    >>> quat = quat_from_euler(angles, seq)
    >>> with np.printoptions(precision=8):
    ...     print(quat) # doctest: +NORMALIZE_WHITESPACE
    [[0.01504849  0.03047982]
     [0.00992359  0.02438147]
     [0.00514916  0.02073308]
     [0.99982426  0.99902285]]

    """
    # check for optional inputs
    if seq is None:
        seq = np.array([3, 1, 2])
    # check for different combinations of angles (scalar, 1D, 2D)
    try:
        ndim = angles.ndim  # type: ignore[union-attr]
    except AttributeError:
        if np.isscalar(angles):
            # assume this is an integer and turn into ndarray with one element
            angles = np.array([angles])
            ndim = 1
        else:
            raise  # pragma: no cover
    # need this check for scalar float64 objects (but not float objects, don't know why)
    if ndim == 0:
        angles = np.array([angles])
        ndim = 1
    if ndim == 1:
        # angles is a 1D, note and make 2D
        is_vector = True
        angles = np.expand_dims(angles, axis=1)
    elif ndim == 2:
        # note that was 2D
        is_vector = False
    else:
        raise ValueError('Unexpected number of dimensions in angle: "{}"'.format(ndim))
    # get the number of quaternions to end up making
    assert isinstance(angles, np.ndarray)
    num = angles.shape[1]
    # initialize output
    quat = np.zeros((QUAT_SIZE, num))
    # check that seq is iterable
    try:
        len(seq)  # type: ignore[arg-type]
    except TypeError:
        seq = np.array([seq])
    # loop through quaternions
    for i in range(num):
        q_temp = np.array([0.0, 0.0, 0.0, 1.0])
        # apply each rotation
        for j in range(len(seq)):  # type: ignore[arg-type]
            q_single = qrot(seq[j], angles[j, i], **kwargs)  # type: ignore[index]
            q_temp = quat_mult(q_temp, q_single, **kwargs)
        # save output
        quat[:, i] = q_temp
    # optionally flatten result
    if is_vector and num == 1:
        quat = quat.flatten()
    return quat


#%% Functions - quat_interp
def quat_interp(time: np.ndarray, quat: np.ndarray, ti: np.ndarray, inclusive: bool = True, **kwargs) -> np.ndarray:
    r"""
    Interpolate quaternions from a monotonic time series of quaternions.

    Parameters
    ----------
    time : ndarray, (A, )
        monotonically increasing time series [sec]
    quat : ndarray, (4, A)
        quaternion series
    ti : ndarray (B, )
        desired time of interpolation, also monotonically increasing [sec]
    inclusive : bool {True, False}, optional
        Whether ti must be only inclusive to the `time` vector.

    Returns
    -------
    qout : ndarray (4, B)
        interpolated quaternion at ti

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.

    Examples
    --------
    >>> from dstauffman.aerospace import quat_interp, qrot
    >>> import numpy as np
    >>> time  = np.array([1, 3, 5])
    >>> quat = np.column_stack((qrot(1, 0), qrot(1, np.pi/2), qrot(1, np.pi)))
    >>> ti = np.array([1, 2, 4.5, 5])
    >>> qout = quat_interp(time, quat, ti)
    >>> print(np.array_str(qout, precision=8, suppress_small=True)) # doctest: +NORMALIZE_WHITESPACE
    [[0. 0.38268343 0.98078528 1. ]
     [0. 0.         0.         0. ]
     [0. 0.         0.         0. ]
     [1. 0.92387953 0.19509032 0. ]]

    """
    # Initializations
    # number of data points to find
    try:
        num = len(ti)
    except TypeError:
        if np.isscalar(ti):
            ti = np.array([ti])
            num = len(ti)
        else:  # pragma: no cover
            raise

    # initialize output
    qout = np.full((QUAT_SIZE, num), np.nan, dtype=float)

    # Simple cases
    if num == 0:
        # optimization for when ti is empty
        return qout
    elif num == 1:
        # optimization for simple use case(s), where ti is a scalar and contained in time
        if ti in time:
            ix = np.where(ti == time)[0]
            if not ix:  # pragma: no branch
                qout = quat[:, ix]
                return qout

    # Check time bounds
    # check for desired times that are outside the time vector
    if len(time) == 0:
        ix_exclusive = np.ones(ti.shape, dtype=bool)
    else:
        ix_exclusive = (ti < time[0]) | (ti > time[-1])
    if np.any(ix_exclusive):
        if inclusive:
            raise ValueError("Desired time not found within input time vector.")
        else:
            logger.log(LogLevel.L8, "Desired time not found within input time vector.")

    # Given times
    # find desired points that are contained in input time vector
    ix_known = np.in1d(ti, time, assume_unique=True)
    ix_input = np.in1d(time, ti, assume_unique=True)

    # set quaternions directly to known values
    qout[:, ix_known] = quat[:, ix_input]

    # find other points to be calculated
    ix_calc = ~ix_known & ~ix_exclusive

    # Calculations
    # find index within time to surround ti, accounting for the end of the vector
    index = np.full(num, INT_TOKEN, dtype=int)
    c = 0
    last_pt = len(time) - 1
    for i in range(num):
        if ix_calc[i]:
            while ti[i] > time[c]:
                c += 1
                if c == last_pt:
                    break
            index[i] = c

    # remove points that are NaN, either they weren't in the time vector, or they were next to a
    # drop out and cannot be interpolated.
    index = index[index != INT_TOKEN]
    # pull out bounding times and quaternions
    t1 = time[index - 1]
    t2 = time[index]
    q1 = quat[:, index - 1]
    q2 = quat[:, index]
    # calculate delta quaternion
    dq12 = quat_norm(quat_mult(q2, quat_inv(q1, **kwargs), **kwargs), **kwargs)
    # find delta quaternion axis of rotation and normalize
    vec = dq12[0:3, :]
    norm_vec = np.sqrt(np.sum(vec**2, axis=0))
    vec = np.divide(vec, norm_vec, out=vec, where=norm_vec != 0)
    # find delta quaternion rotation angle
    ang = 2 * np.arcsin(norm_vec)
    # scale rotation angle based on time
    scaled_ang = ang * (ti[ix_calc] - t1) / (t2 - t1)
    # set to no rotation for any null axis
    scaled_ang[norm_vec == 0] = 0
    # find scaled delta quaternion
    dq = quat_from_axis_angle(vec, scaled_ang, **kwargs)
    # calculate desired quaternion
    qout_temp = quat_norm(quat_mult(dq, q1, **kwargs))
    # store into output structure
    qout[:, ix_calc] = qout_temp

    # Enforce sign convention on scalar quaternion element.
    enforce_pos_scalar(qout, inplace=True)

    # Drop result for single time point to single dimension
    if num == 1:
        qout = qout[:, 0]

    return qout


#%% Functions - quat_inv
def quat_inv(q1: np.ndarray, inplace: bool = False, **kwargs) -> np.ndarray:
    r"""
    Return the inverse of a normalized quaternions.

    Parameters
    ----------
    q1 : ndarray, (4,) or (4, N)
        input quaternion
    inplace : bool, optional, default is False
        Whether to modify the input in-place

    Returns
    -------
    q2 : ndarray, (4,) or (4, N)
        inverse quaterion

    See Also
    --------
    quat_norm, quat_mult, quat_prop, quat_times_vector, quat_to_dcm, quat_to_euler,
    quat_from_euler

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.

    Examples
    --------
    >>> from dstauffman.aerospace import qrot, quat_inv
    >>> from numpy import pi
    >>> q1 = qrot(1, pi/2)
    >>> q2 = quat_inv(q1)
    >>> with np.printoptions(precision=8):
    ...     print(q2) # doctest: +NORMALIZE_WHITESPACE
    [-0.70710678 -0. -0. 0.70710678]

    """
    q2 = q1 if inplace else q1.copy()
    # check for empty case
    if q1.size == 0:
        return q2
    # size check
    quat_assertions(q1, **kwargs)
    # invert the quaternions
    if q1.ndim == 1:
        # optimized single quaternion case
        q2 *= np.array([-1, -1, -1, 1])
    else:
        # general case
        q2[:] = np.vstack((-q2[0, :], -q2[1, :], -q2[2, :], q2[3, :]))
    quat_assertions(q2, **kwargs)
    return q2


#%% Functions - quat_mult
def quat_mult(a: np.ndarray, b: np.ndarray, **kwargs) -> np.ndarray:
    r"""
    Multiply quaternions together.

    Parameters
    ----------
    a : ndarray, (4,) or (4, N)
        input quaternion one
    b : ndarray, (4,) or (4, N)
        input quaternion two

    Returns
    -------
    c : ndarray, (4,) or (4, N)
        result of quaternion multiplication

    See Also
    --------
    quat_inv, quat_norm, quat_prop, quat_times_vector, quat_to_dcm, quat_to_euler,
    quat_from_euler

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.
    #.  Each of (a, b) may be either a single quaternion (4,) or an array of quaternions (4, N).
        If `a` and `b` are both single quaternions, then return b*a. If either (but not both) is
        an array of quaternions, then return the product of the single quaternion times each element
        of the array. If both are rows of quaternions, multiply corresponding columns.
        `c` will have size (4,) in the first case, and (4, N) in the other cases.
    #.  The quaternions `a` and `b` describe successive reference frame changes, i.e., a is
        expressed in the coordinate system resulting from b, not in the original coordinate system.
        In Don Reid's tutorial, this is called the R- version.

    Examples
    --------
    >>> from dstauffman.aerospace import qrot, quat_mult
    >>> from numpy import pi
    >>> a = qrot(1, pi/2)
    >>> b = qrot(2, pi)
    >>> c = quat_mult(a, b)
    >>> print(np.array_str(c, precision=8, suppress_small=True)) # doctest: +NORMALIZE_WHITESPACE
    [ 0. 0.70710678 -0.70710678 0. ]

    """
    # check for vectorized inputs
    is_single_a = a.ndim == 1 and a.size == QUAT_SIZE
    is_single_b = b.ndim == 1 and b.size == QUAT_SIZE
    # check for null case
    if a.size * b.size == 0:
        if min(a.shape[0], b.shape[0]) == 0:
            c: np.typing.NDArray[np.float64] = np.array([])
        else:
            if a.size == 0:
                c = np.zeros(a.shape)
            else:
                c = np.zeros(b.shape)
        quat_assertions(c, **kwargs)
        return c
    # single quaternion inputs case
    if is_single_a and is_single_b:
        # fmt: off
        c = np.array([
            [ a[3],  a[2], -a[1],  a[0]],
            [-a[2],  a[3],  a[0],  a[1]],
            [ a[1], -a[0],  a[3],  a[2]],
            [-a[0], -a[1], -a[2],  a[3]],
        ]) @ b
        # fmt: on
        # enforce positive scalar component
        if c[3] < 0:
            c = np.negative(c, out=c)
    # vectorized inputs
    else:
        # alias the rows
        a1 = a[0, ...]
        a2 = a[1, ...]
        a3 = a[2, ...]
        a4 = a[3, ...]
        b1 = b[0, ...]
        b2 = b[1, ...]
        b3 = b[2, ...]
        b4 = b[3, ...]
        # compute the combine multiplication result
        # fmt: off
        c = np.array([
            +b1 * a4 + b2 * a3 - b3 * a2 + b4 * a1,
            -b1 * a3 + b2 * a4 + b3 * a1 + b4 * a2,
            +b1 * a2 - b2 * a1 + b3 * a4 + b4 * a3,
            -b1 * a1 - b2 * a2 - b3 * a3 + b4 * a4,
        ])
        # fmt: on
        # enforce positive scalar component
        c[:, c[3, :] < 0] = -c[:, c[3, :] < 0]
    quat_norm(c, inplace=True, **kwargs)
    quat_assertions(c, **kwargs)
    return c


#%% Functions - quat_norm
def quat_norm(x: np.ndarray, /, inplace: bool = False, **kwargs) -> np.ndarray:
    r"""
    Normalize each column of the input matrix.

    Parameters
    ----------
    x : ndarray
        input quaternion
    inplace : bool, optional, default is False
        Whether to modify the input in-place

    Returns
    -------
    y : ndarray
        normalized quaternion

    See Also
    --------
    quat_mult, quat_inv, quat_prop, quat_times_vector, quat_to_dcm, quat_to_euler, quat_from_euler

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.

    Examples
    --------
    >>> from dstauffman.aerospace import quat_norm
    >>> import numpy as np
    >>> x = np.array([0.1, 0, 0, 1])
    >>> y = quat_norm(x)
    >>> with np.printoptions(precision=8):
    ...     print(y) # doctest: +NORMALIZE_WHITESPACE
    [0.09950372 0. 0. 0.99503719]

    """
    y = x if inplace else x.copy()
    # divide input by its column vector norm
    y /= np.sqrt(np.sum(x * x, axis=0))
    quat_assertions(y, **kwargs)
    return y


#%% Functions - quat_prop
def quat_prop(quat: np.ndarray, delta_ang: np.ndarray, *, renorm: bool = True, **kwargs) -> np.ndarray:
    r"""
    Approximate propagation of a quaternion using a small delta angle.

    Parameters
    ----------
    quat : ndarray, (4, 1)
        normalized input quaternion
    delta_ang : ndarray, (3, 1)
        delta angles in x, y, z order [rad]
    inplace : bool, optional, default is False
        Whether to modify the input in-place
    renorm : bool {True, False}, optional
        Whether to renormalize the propagated quaternion

    Returns
    -------
    quat_new : ndarray, (4, 1)
        propagated quaternion, optionally re-normalized

    See Also
    --------
    quat_mult, quat_inv, quat_norm, quat_times_vector, quat_to_dcm, quat_to_euler, quat_from_euler

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.

    Examples
    --------
    >>> from dstauffman.aerospace import quat_prop
    >>> import numpy as np
    >>> quat      = np.array([0., 0., 0., 1.])
    >>> delta_ang = np.array([0.01, 0.02, 0.03])
    >>> quat_new  = quat_prop(quat, delta_ang)
    >>> with np.printoptions(precision=8):
    ...     print(quat_new) # doctest: +NORMALIZE_WHITESPACE
    [0.00499913  0.00999825  0.01499738  0.99982505]

    """
    # TODO: expand to allow a time history of delta_ang
    # compute angle rate matrix (note: transposed to make 'F' order), use it to compute a delta
    # quaternion, and then propagate by adding the delta
    # fmt: off
    quat_new: np.ndarray = quat + 0.5 * np.array([
        [      0      , -delta_ang[2],   delta_ang[1], -delta_ang[0]],
        [ delta_ang[2],       0      ,  -delta_ang[0], -delta_ang[1]],
        [-delta_ang[1],  delta_ang[0],       0       , -delta_ang[2]],
        [ delta_ang[0],  delta_ang[1],   delta_ang[2],       0      ],
    ]).T @ quat
    # fmt: on
    # ensure positive scalar component
    if quat_new[3] < 0:
        quat_new[:] = -quat_new
    # renormalize and return
    if renorm:
        quat_norm(quat_new, inplace=True, **kwargs)
    quat_assertions(quat_new, **kwargs)
    return quat_new


#%% Functions - quat_times_vector
def quat_times_vector(quat: np.ndarray, v: np.ndarray) -> np.ndarray:
    r"""
    Multiply quaternion(s) against vector(s).

    Parameters
    ----------
    quat : ndarray, (4,) or (4, N)
        quaternion(s)
    v : ndarray, (3,) or (3, N)
        input vector(s)

    Returns
    -------
    vec : ndarray, (3,) or (3, N)
        product vector(s)

    See Also
    --------
    quat_mult, quat_inv, quat_norm, quat_prop, quat_to_dcm, quat_to_euler, quat_from_euler

    Notes
    -----
    #.  Adapted from GARSE by David C. Stauffer in April 2015.
    #.  This function will broadcast a single vector or quaternion to the other dimension

    References
    ----------
    Steps to algorithm:
        1.  qv = quat(1:3) x v
        2.  vec = v + 2*[ -( quat(4) * qv ) + (quat(1:3) x qv) ]

    Examples
    --------
    >>> from dstauffman.aerospace import quat_times_vector
    >>> import numpy as np
    >>> quat = np.array([[0, 1, 0, 0], [1, 0, 0, 0]]).T
    >>> v = np.array([[1, 0, 0], [2, 0, 0]]).T
    >>> vec = quat_times_vector(quat, v)
    >>> print(vec) # doctest: +NORMALIZE_WHITESPACE
    [[-1  2]
     [ 0  0]
     [ 0  0]]

    """
    # Multiple quaternions, multiple vectors
    qv = np.cross(quat[:3, ...], v, axis=0)
    vec = np.transpose(v.T + 2 * (-quat[3, ...] * qv + np.cross(quat[:3, ...], qv, axis=0)).T)
    return vec


#%% Functions - quat_to_euler
def quat_to_euler(quat: np.ndarray, seq: Union[Tuple[int, int, int], List[int], np.ndarray] = None, **kwargs) -> np.ndarray:
    r"""
    Convert quaternion to Euler angles for one of 6 input angle sequences.

    Parameters
    ----------
    quat : ndarray, (4,) or (4, N)
        quaternion
    seq : ndarray, {(3, 1, 2), (1, 2, 3), (2, 3, 1), (1, 3, 2), (2, 1, 3), (3, 2, 1)}
        euler angle sequence, where:
            1 = X axis, or roll
            2 = Y axis, or pitch
            3 = Z axis, or yaw

    Returns
    -------
    euler : ndarray, (3, N)
        Euler angles [rad]

    See Also
    --------
    quat_mult, quat_inv, quat_norm, quat_prop, quat_times_vectore, quat_from_euler

    Notes
    -----
    #.  Additional keyword arguments are passed on to quat_assertions function.
    #.  Adapted from GARSE by David C. Stauffer in April 2015.

    References
    ----------
    #.  Appendix E of Wertz, page 764
    #.  Appendix I of Kane, Likins, and Levinson, page 423

    Examples
    --------
    >>> from dstauffman.aerospace import quat_to_euler
    >>> import numpy as np
    >>> quat = np.array([[0, 1, 0, 0], [0, 0, 1, 0]]).T
    >>> seq = [3, 1, 2]
    >>> euler = quat_to_euler(quat, seq)
    >>> with np.printoptions(precision=8):
    ...     print(euler) # doctest: +NORMALIZE_WHITESPACE
    [[-0.         -3.14159265]
     [ 0.          0.        ]
     [ 3.14159265 -0.        ]]

    """
    # check for optional inputs
    if seq is None:
        seq = (3, 1, 2)
    # assert quaternion checks
    quat_assertions(quat, **kwargs)
    assert len(seq) == 3, 'Sequence must have len of 3, not "{}"'.format(len(seq))
    if quat.ndim == 1:
        # quat is a 1D
        is_vector = True
        quat = np.expand_dims(quat, axis=1)
    else:
        # note that was 2D
        is_vector = False

    # initialize output
    num = quat.shape[1]
    euler = np.zeros((3, num))

    # Loop through quaternions
    for i in range(num):
        # calculate DCM from quaternion
        dcm = quat_to_dcm(quat[:, i])
        # build sequence str
        seq_str = str(int(seq[0])) + str(int(seq[1])) + str(int(seq[2]))
        # calculate terms based on sequence order
        # fmt: off
        if seq_str == "123":
            # Identical to KLL pg 423
            c2_c3                     =  dcm[0, 0]
            s1_s2_c3_plus_s3_c1       =  dcm[1, 0]
            minus_c1_s2_c3_plus_s3_s1 =  dcm[2, 0]
            minus_c2_s3               =  dcm[0, 1]
            minus_s1_s2_s3_plus_c3_c1 =  dcm[1, 1]
            c1_s2_s3_plus_c3_s1       =  dcm[2, 1]
            s2                        =  dcm[0, 2]
            s1_c2                     =  dcm[1, 2]
            c1_c2                     =  dcm[2, 2]
            group = 1
        elif seq_str == "231":
            c1_c2                     =  dcm[0, 0]
            minus_c1_s2_c3_plus_s3_s1 =  dcm[0, 1]
            c1_s2_s3_plus_c3_s1       =  dcm[0, 2]
            s2                        =  dcm[1, 0]
            c2_c3                     =  dcm[1, 1]
            minus_c2_s3               =  dcm[1, 2]
            s1_c2                     =  dcm[2, 0]
            s1_s2_c3_plus_s3_c1       =  dcm[2, 1]
            minus_s1_s2_s3_plus_c3_c1 =  dcm[2, 2]
            group = 1
        elif seq_str == "312":
            s1_s2_c3_plus_s3_c1       =  dcm[0, 2]
            minus_c1_s2_c3_plus_s3_s1 =  dcm[1, 2]
            minus_c2_s3               =  dcm[2, 0]
            minus_s1_s2_s3_plus_c3_c1 =  dcm[0, 0]
            c1_s2_s3_plus_c3_s1       =  dcm[1, 0]
            s2                        =  dcm[2, 1]
            s1_c2                     =  dcm[0, 1]
            c1_c2                     =  dcm[1, 1]
            c2_c3                     =  dcm[2, 2]
            group = 1
        elif seq_str == "132":
            c2_c3                     =  dcm[0, 0]
            minus_c1_s2_c3_plus_s3_s1 =  dcm[1, 0]
            s1_s2_c3_plus_s3_c1       = -dcm[2, 0]
            s2                        = -dcm[0, 1]
            c1_c2                     =  dcm[1, 1]
            s1_c2                     =  dcm[2, 1]
            minus_c2_s3               = -dcm[0, 2]
            c1_s2_s3_plus_c3_s1       = -dcm[1, 2]
            minus_s1_s2_s3_plus_c3_c1 =  dcm[2, 2]
            group = 2
        elif seq_str == "213":
            s1_s2_c3_plus_s3_c1       = -dcm[0, 1]
            minus_c1_s2_c3_plus_s3_s1 =  dcm[2, 1]
            minus_c2_s3               = -dcm[1, 0]
            minus_s1_s2_s3_plus_c3_c1 =  dcm[0, 0]
            c1_s2_s3_plus_c3_s1       = -dcm[2, 0]
            s2                        = -dcm[1, 2]
            s1_c2                     =  dcm[0, 2]
            c1_c2                     =  dcm[2, 2]
            c2_c3                     =  dcm[1, 1]
            group = 2
        elif seq_str == "321":
            s1_s2_c3_plus_s3_c1       = -dcm[1, 2]
            minus_c1_s2_c3_plus_s3_s1 =  dcm[0, 2]
            minus_c2_s3               = -dcm[2, 1]
            minus_s1_s2_s3_plus_c3_c1 =  dcm[1, 1]
            c1_s2_s3_plus_c3_s1       = -dcm[0, 1]
            s2                        = -dcm[2, 0]
            s1_c2                     =  dcm[1, 0]
            c1_c2                     =  dcm[0, 0]
            c2_c3                     =  dcm[2, 2]
            group = 2
        else:
            raise ValueError('Invalid axis rotation sequence: "{}"'.format(seq_str))
        # fmt: on

        # Compute angles
        if s1_c2 == 0 and c1_c2 == 0:
            theta1 = 0
        else:
            if group == 1:
                theta1 = np.arctan2(-s1_c2, c1_c2)
            else:
                theta1 = np.arctan2( s1_c2, c1_c2)  # fmt: skip
        # compute sin and cos
        s1 = np.sin(theta1)
        c1 = np.cos(theta1)
        # build remaining thetas
        # fmt: off
        s3     =       s1_s2_c3_plus_s3_c1 * c1 +  minus_c1_s2_c3_plus_s3_s1 * s1
        c3     = minus_s1_s2_s3_plus_c3_c1 * c1 +        c1_s2_s3_plus_c3_s1 * s1
        theta3 = np.arctan2(s3, c3)
        c2     = c2_c3 * c3 - minus_c2_s3 * s3
        theta2 = np.arctan2(s2, c2)
        # fmt: on

        # Store output
        euler[:, i] = np.array([theta1, theta2, theta3])

    # optionally flatten result and then return answer
    if is_vector:
        euler = euler.flatten()
    return euler


#%% Unit test
if __name__ == "__main__":
    unittest.main(module="dstauffman.tests.test_aerospace_quat", exit=False)
    doctest.testmod(verbose=False)
